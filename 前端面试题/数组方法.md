# ES5 数组方法

## push

## pop

## unshift

## shift

## Splice 

> 改变原数组 返回删除项

```js
var arr = ['a','b','c','d'];

// 删除 arr.splice(下标, 删除项数)
arr.splice(0,1); // ['a']

// 替换 arr.splice(起始位置下标, 删除项数, 插入元素)
arr.splice(2,1,11); // ['c']

// 添加 
arr.splice(2,0,'aa'); // []
```



## Slice 数组裁剪

> 不会改变原数组， 返回裁剪出到部分

```js
var arr = ['a','b','c','d'];
arr.slice(2); // 一个参数，从参数下标开始到结束 ['c','d']

arr.slice(1,3); // 从下标2开始，到下标4结束，不包括4。['b','c']

arr.slice(-3,3); //参数为负数时 = 参数+数组长度(1,3) ['b','c']
```

## map 和 forEach

```js

```





# ES6 数组方法

## ... 扩展运算符

```js
console.log(...[1, 2, 3]); // 1 2 3
console.log('a',...[1, 2, 3]); // 'a' 1 2 3

// 将伪数组转为数组
[...document.querySelectorAll('div')] // [<div>,<div>]

// 将一个数组添加到另一个数组后面
ES5 => Array.prototype.push.apply(arr1, arr2);  // 使用 apply 展开数组
ES6 => arr1.push(...arr2); // 使用 ...

// 复制数组
const a = [1,[2,3]];
ES5 => const b = a.concat(); 
ES6 => const b = [...a];

// 合并数组
arr1.concat(arr2, arr3); // es5
[...arr1,...arr2,...arr3]; // es6

// 字符串转数组
[...'hell']; // ['h','e','l','l']
```



## Array.from(val, map,this)

> Array.from(处理成数组,map函数,用来绑定map函数中的this)

>  将伪数组（具有length属性的） 和 可遍历（部署了Interator接口）的对象转为数组。
>
> 同时第二个参数具有 map 函数的功能。

```js
// 只有 length 属性的伪数组
Array.from({length:2}); // [undefined,undefined]

// 伪数组转数组
let lis = document.querySelectorAll('li');
Array.from(lis); // [li,li]

// arguments 伪数组转数组
function ff(){
	var args = Array.from(arguments);
  console.log(args); // [1,2]
}
ff(1,2);

// 具备 interator 接口
Array.from('hell'); // ['h','e','l','l']
```

```js
// 第二个参数 类似于map方法
Array.from([1, 2, 3], (x) => x * x); // ['1','4','9']
等同于 Array.from([1,2,3]).map(x => x * x);

// 创建一个包含 0-99 的数组
Array.from({length:100},(item,index)=> index); // [0,1,2,...,99]
```

## Array.of(val1,val2...)

> 将一组值转换为数组 

```js
// 为了解决 ES5 中 Array()的不足
Array(2); // [,] 占据空间的空值

Array.of() // []
Array.of(undefined) // [undefined]
Array.of(1,2) // [1,2]
Array.of('1',2) // ['1',2]
```

```js
// 实现 Array.of 方法
function ArrayOf(){
  return [].slice.call(arguments);
}
```



## copyWithin(tart,start,end) 数组的实例

> 将指定位置的成员 复制到其他位置并且覆盖。 返回当前数组。
>
> copyWithin( 从哪个下标开始覆盖, 从哪个下标开始复制, 到哪个下标之前结束复制 )

```js
// 将3号位复制到0号位
[1, 2, 3, 4, 5].copyWithin(0, 3, 4)
// [4, 2, 3, 4, 5]

// -2相当于3号位，-1相当于4号位 => 负数+length = 对应位置
[1, 2, 3, 4, 5].copyWithin(0, -2, -1)
// [4, 2, 3, 4, 5]

// 将3号位复制到0号位
[].copyWithin.call({length: 5, 3: 1}, 0, 3)
// {0: 1, 3: 1, length: 5}

// 将2号位到数组结束，复制到0号位
let i32a = new Int32Array([1, 2, 3, 4, 5]);
i32a.copyWithin(0, 2);
// Int32Array [3, 4, 5, 4, 5]

// 对于没有部署 TypedArray 的 copyWithin 方法的平台
// 需要采用下面的写法
[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);
// Int32Array [4, 2, 3, 4, 5]

```



## find() 数组的实例

> 查找第一个符合条件的 `项` 并返回。 find( 回调函数, 绑定回调函数的this )

```js
// 只使用第一个参数
[1,4].find( (val, index, arr)=> val>1 );  // 4

// 使用第二个参数 将回调函数 this 指向 person 对象
function f(v){
  return v > this.age;
}
let person = {name: 'John', age: 20};
[10, 12, 26, 15].find(f, person);    // 26
```

## findIndex() 数组的实例

> 查找第一个符合条件的 `索引` 并返回。 find( 回调函数, 绑定回调函数的this )



## fill(val, start,end) 数组的实例

> 使用给定值填充数组。 fill( 用来填充数组的值,  填充的起始位置, 填充的结束位置  )

```js
// 用于初始化数组
['a', 'b', 'c'].fill(7)	// [7, 7, 7]

new Array(3).fill(7)	// [7, 7, 7]


// 三个参数使用
['a', 'b', 'c'].fill(7, 1, 2)		// ['a', 7, 'c']
```

## entries()，keys() 和 values()  数组的实例

> 三者都是用来遍历数组，返回的是一个遍历器对象（Interator）。
>
> `keys()` 用来遍历键名 
>
> `values()`用来遍历键值 
>
>  `entries()`用来遍历键值对

```js
for (let index of ['a', 'b'].keys()) {
  console.log(index);  // 0 1
}


for (let elem of ['a', 'b'].values()) {
  console.log(elem);  // 'a' 'b'
}
// 'a'
// 'b'

for (let [index, elem] of ['a', 'b'].entries()) {
  console.log(index, elem); // 0 "a" ; 1 "b"
}
```



## includes(val) 数组实例

> `Array.prototype.includes`方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的`includes`方法类似

```js
// includes : 判断某值是否存在与数组;
// indexOf : 判断某值第一次出现在数组位置; 判断规则 ===, 所以会得出 [NaN].indexOf(NaN)为 -1

[1, 2, 3].includes(2)     // true
[1, 2, 3].includes(4)     // false
[1, 2, NaN].includes(NaN) // true
```

```js
// 判断浏览器是否兼容 includes()

const contains = (() =>
  Array.prototype.includes
    ? (arr, value) => arr.includes(value)
    : (arr, value) => arr.some(el => el === value)
)();
contains(['foo', 'bar'], 'baz'); // => false
```

## flat()、flatMap() 数组实例

> flat 将多维数组转成一维数组。  返回新数组
>
> flat( n维-1|| Infinity )

```js
[1, 2, [3, 4]].flat()		// [1, 2, 3, 4]

[1, 2, [3, [4, 5]]].flat(2)		// [1, 2, 3, 4, 5]

[1, 2, [3, [4, 5]]].flat(Infinity)		// [1, 2, 3, 4, 5]
```

> flatMap 对所有数组成员进行一个函数 然后执行 flat 方法。 返回一个新数组。
>
> 只能解开二维数组及其一下的

```js
// 相当于 [[2, 4], [3, 6], [4, 8]].flat()
[2, 3, 4].flatMap((x) => [x, x * 2])	// [2, 4, 3, 6, 4, 8]
```



## 空位

> 数组有长度但是没有任何值。 js对空位的处理不一样，建议不要出现空位

```js
// es6 会将空位处理成 undefined
```

