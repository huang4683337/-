## var 声明以及变量提升（Hoisting）机制

在 JavaScript 中有一个奇怪的特点就是我们可以在变量和函数的声明之前使用它们。

```js
sayName();
function sayName(){
  console.log('名字');	// 名字
}

//	在定义函数 `sayName` 之前执行它，结果能调用函数。
```


```js
console.log(name);	//	name is not defined

//	直接打印 `name` 报错； 为定义
```


```js
console.log(name);	//	undefined
var name = '我是名字';

//	在定义`name`之前输出 `name` 结果为 undefined

// 以上情况等价于
var name;
console.log(name);
name = '我是名字';
```



**那么产生上述结果的原因是什么呢？**

JavaScript 是单线程语言，执行顺序是自上而下的。但是它并不是逐行分析执行的，而是一段代码一段代码去执行的。JavaScript 实际上和一般语言一样也存在编译阶段。

在对 JavaScript 进行编译时，首先会检测到所有的变量和函数声明，然后将这个变量和函数声明放在一个[Lexical Environment]() 的数据结构内存中，并进行初始化设置，所以变量能在声明之前使用，给使用着的感觉就是把变量给提升到代码的头部了。

```js
sayName();
function sayName(){
  console.log('名字');	// 名字
}


// 函数在声明在编译阶段会被添加到词法环境（Lexical Environment）
lexicalEnvironment = {
  sayName: < func >
}

// 在 JavaScript 引擎遇到 sayNmae 函数时，就会从词法环境中找到并执行
```

```js
console.log(name);	// undefined
var name = '我是名字';
console.log(name);	//	我是名字

// 编译阶段：变量的声明在编译阶段时会给一个默认的 undefined
lexicalEnvironment = {
  name: undefined
}

// 所以在第一次 console.log(name) 时，结果为 undefined
// 第二次 console.log(name) 之前，对 name 进行了赋值，所以输出对应的值
```





## 块级声明

块级声明的变量在指定作用域外无法访问, 块级作用域（又被称为词法作用域）存在于:

+ 函数之间
+ 块中 ( 字符{ 和 }之间的区域 )

==块级声明不会出现变量提升的原因在于：在编译阶段不会对生命的变量进行初始化赋值，只有在执行阶段遇到词法绑定（对变量赋值）时才会进行初始化。==

### let声明变量

+ 不会进行变量提升 (只会在指定块内生效)

```javascript
if(true){
	let value = 'blue';
	console.log(value); // blue
}else{
	console.log(value); // defined (意思为变量为声明)
}
console.log(value); // defined
```

> 一旦离开定义变量的 {  }, JS 会立刻销毁声明的变量, 所以其他地方访问时,此变量就是没有声明 

+ 禁止重复声明

```javascript
let a = 0;
var a = 3; // Identifier 'a' has already been declared

let a = 0;
console.log(a); // 0
if(true){
    let a = 3;
    console.log(a); //3
}
```



### const

+ 必须进行初始化

```javascript
const maxItem; //Missing initializer in const declaration

const maxItem = 10; // 正确
```

+ 一旦声明不能更改

```javascript
const maxItem = 10;
maxItem = 22; //Assignment to constant variable
```

```javascript
// 对于对象来说 对象里的值是可以修改的
const person = {
    name: '名字'
}

person.name = '名字被修改';

console.log(person); // {name: "名字被修改"}
```

+ 不会进行变量提升 (只会在指定块内生效)
+ 禁止重复声明



## 临时死区

> temporal dead zone ==> TDZ

### 为什么会出现临时死区

先来看看 ES6 标准中对 `let/const` 声明中的解释 [第13章](http://www.ecma-international.org/ecma-262/6.0/#sec-let-and-const-declarations)，有如下一段文字：

> The variables are created when their containing Lexical Environment is instantiated but may not be accessed inany way until the variable’s LexicalBinding is evaluated.

翻译过来大概就是

> 当程序的控制流程在新的作用域（`module` `function` 或 `block` 作用域）进行实例化时，在此作用域中用let/const声明的变量会先在作用域中被创建出来，但因此时还未进行词法绑定（没有对变量进行赋值），所以是不能被访问的，如果访问就会抛出错误。
>
> 因此，在这运行流程进入作用域创建变量，到变量可以被访问之间的这一段时间，就称之为暂时死区。

```javascript
if(true){
   console.log( typeof value ); //value is not defined
   let value = 'blue';
}
```



## 循环中的块级作用域

```js
for(var i=0; i<10; i++){
    console.log('for循环中',i);
}
console.log('for循环外',i);

// 等价于
var i;
for(i=0; i<10; i++){
    console.log('for循环中',i);	// 0-9
}
console.log('for循环外',i);	// 此处可以访问到 i 是因为 var 的变量提升
```

```js
// 当使用 let 实现块级作用域后
for(let i=0; i<10; i++){
    console.log('for循环中',i);
}
console.log('for循环外',i);	//	i is not defined
```



### 块级作用域的使用

在开发中经常会遇到以下问题：

```html
<ul>
    <li>1</li>
    <li>2</li>
    <li>3</li>
    <li>4</li>
</ul>
```

```js
var btn = document.querySelectorAll('li');

for (var i = 0; i < btn.length; i++) {
    btn[i].onclick = function () {
        console.log(i);
    }
}

// 等价于
var i;
for(i=0; i < btn.length; i++){
    btn.onclick = function(){
        console.log(i);	//	每次点击输出的结果都是 10
    }
}

/*
 发生以上情况的原因是：执行 for 循环时每次都会创建一个有关点击的函数，但是因为在循环时还未进行点击，所以相关函数病咩有执行。 在循环时会对 i 不断的进行赋值，当循环结束时 i 为最终结果。

当通过点击触发函数时，每次访问的都是最终的结果
*/
```



使用 let 解决上述问题：

```js
for(let i=0; i < btn.length; i++){
    btn.onclick = function(){
        console.log(i);	//	每次点击输出的结果都是 10
    }
}

/*
为什么使用 let 可以解决上述问题？
因为 let 的块级作用域的原因，每次都会产生一个 {}, 各个 {} 之间互不干扰。所以实现了类似闭包的效果。
*/
```



