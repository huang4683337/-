## var 声明以及变量提升机制

## 块级声明

块级声明的变量在指定作用域外无法访问, 块级作用域存在于:

+ 函数之间
+ 块中 ( 字符{ 和 }之间的区域 )



### let声明变量

+ 不会进行变量提升 (只会在指定块内生效)

```javascript
if(true){
	let value = 'blue';
	console.log(value); // blue
}else{
	console.log(value); // defined (意思为变量为声明)
}
console.log(value); // defined
```

> 一旦离开定义变量的 {  }, JS会立刻销毁声明的变量, 所以其他地方访问时,此变量就是没有声明 

+ 禁止重复声明

```javascript
let a = 0;
var a = 3; // Identifier 'a' has already been declared

let a = 0;
console.log(a); // 0
if(true){
    let a = 3;
    console.log(a); //3
}
```



### const

+ 必须进行初始化

```javascript
const maxItem; //Missing initializer in const declaration

const maxItem = 10; // 正确
```

+ 一旦声明不能更改

```javascript
const maxItem = 10;
maxItem = 22; //Assignment to constant variable
```

```javascript
// 对于对象来说 对象里的值是可以修改的
const person = {
    name: '名字'
}

person.name = '名字被修改';

console.log(person); // {name: "名字被修改"}
```

+ 不会进行变量提升 (只会在指定块内生效)
+ 禁止重复声明



## 临时死区

> temporal dead zone ==> TDZ

### 为什么会出现临时死区

先来看看 ES6 标准中对 `let/const` 声明中的解释 [第13章](http://www.ecma-international.org/ecma-262/6.0/#sec-let-and-const-declarations)，有如下一段文字：

> The variables are created when their containing Lexical Environment is instantiated but may not be accessed inany way until the variable’s LexicalBinding is evaluated.

翻译过来大概就是

> 当程序的控制流程在新的作用域（`module` `function` 或 `block` 作用域）进行实例化时，在此作用域中用let/const声明的变量会先在作用域中被创建出来，但因此时还未进行词法绑定，所以是不能被访问的，如果访问就会抛出错误。
>
> 因此，在这运行流程进入作用域创建变量，到变量可以被访问之间的这一段时间，就称之为暂时死区。

```javascript
if(true){
   console.log( typeof value ); //value is not defined
   let value = 'blue';
}
```
