# 跨域

## 前言

在前后端数据交互中经常会遇到跨域的问题。那么什么是跨域？有哪几种方式能实现跨域呢？

[参考地址](https://zhuanlan.zhihu.com/p/55869398)

## 同源策略

### 什么是同源策略

跨域的主要是因为`浏览器的同源策略`引起的。

同源策略是指: `协议`、`域名`、`端口` 完全一至。只要其中的一项不一致，想要实现数据交互就需要跨域了。

比如： `https://www.baidu.com:8080/a.html` 这个网址：

```shell
协议: https://
域名: www.baidu.com
端口: 8080              # 默认端口可以省略
```


以下表格通过与`https://www.baidu.com:8080/a.html`对比。
|            浏览器地址             |      是否同源      | 是否需要跨域 |
| :-------------------------------: | :----------------: | :----------: |
|   https://www.baidu.com/b.html    |        同源        |      否      |
|   https://www.qiandu.com/a.html   | 不同源 （域名不同) |      是      |
|    http://www.baidu.com/a.html    | 不同源 （协议不同) |      是      |
| https://www.baidu.com:8888/a.html | 不同源 （端口不同) |      是      |



### 为什么要有同源策略

同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。

**设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？**

很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。

由此可见，`同源政策`是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。



### 同源策略限制的范围

随着互联网的发展, `同源政策` 越来越严格。

目前, 如果非同源, 共有三种行为受到限制。

+ Cookie、LocalStorage 和 IndexDB 无法读取（浏览器的存储）
+ DOM 无法获得（针对DOM的查询）
+ AJAX 请求不能发送（接口的请求）

但是有三个标签是允许跨域加载资源：

+ <img src=""></img>

+ <link href=""></link>

+ <script src=""></script>



## 如何突破浏览器的同源策略

### JSONP

**原理：**利用 `src`  属性不受同源策略限制的漏洞。通过<script>从其他来源动态的引入数据。

**特点：**兼容性好，可以解决主流浏览器跨域访问数据。但是只能使用`get`方式，还有可能会遭受`XSS`攻击。

**实现：**用户在前端页面通过点击按钮等操作触发一个函数，动态的创建一个script标签，改变其src属性为服务给的路径，然后将script插入到html中。请求成功后删除script标签。	

==注意：==**前端需要传一个回调函数给后端服务，用去接受请求成功或者失败的信息**



**前端部分**

```html
<button onclick="submit()">点击</button>
```

```js
let script='';

function submit() {
    script = document.createElement('script');
    script.src = 'http://localhost:3000/get?ws=sss&callback=getData';
    document.head.appendChild(script);
}

// 请求成功回调函数
function getData(data) {
    console.log(data);
  	// 删除 script 标签
    document.head.removeChild(script)
}
```

**后端部分**

```js
server.post('/post', (req, res) => {
  let { wd, callback } = req.query;
  res.send(`${callback}('msgInfo')`);
})
```



在以上的基础上利用 promise 对前端部分进行优化

```js
// 点击时进行请求
function submit() {
    jsonp({
        url: 'http://localhost:3000/get',
        params: { wd: 'info' },
        callback: 'getData'
    }).then(data => {
        console.log(data)
    })
}


// 封装 jsonp 函数
function jsonp({ url, params, callback }) {
    return new Promise((resolve, reject) => {
        let script = document.createElement('script')
        window[callback] = function (data) {
            resolve(data)
            document.body.removeChild(script)
        }
        params = { ...params, callback } // wd=b&callback=show
        let arrs = []
        for (let key in params) {
            arrs.push(`${key}=${params[key]}`)
        }
        script.src = `${url}?${arrs.join('&')}`
        document.body.appendChild(script)
    })
}
```

当然如果你想偷懒的话可以直接使用 jQuery 的 jsonp 形式

```js
$.ajax({
    url: "http://localhost:3000/get",
    dataType: "jsonp",
    type: "get",//可以省略
    jsonpCallback: "getData",//->自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略
    jsonp: "callback",//->把传递函数名的那个形参callback，可省略
    success: function (data) {
        console.log(data);
    }
});
```



### postMessage + iframe

`postMessage`是 `HTML5 XMLHttpRequest Level 2`中的API。

**原理：**

**特点：**可以实现跨窗口的通信，不论这两个窗口是否同源都可以实现通信。

```js
// 发送消息
window.postMessage('发送的信息'，'就收消息页面的地址 / *');

// 接受消息
window.addEventListener('message', function (e) {
	console.log(e.data);
  
  // e.source 相当于发送消息的窗口
	e.source.postMessage('Nice to see you!', '*');
}, false);
```

**实现：**

```js
// http://www.A.com/a.html

// 创建一个 iframe，地址指向 http://www.B.com/b.html
let body = document.querySelector('body');
let iframe = document.createElement('iframe');

creatIframe();

function creatIframe() {
    iframe.src = 'http://www.B.com/b.html';
    iframe.style.display = 'none';
    body.appendChild(iframe);
}


iframe.onload = function () {
  // iframe 加载完毕 通过postMessage('发送的信息'，'就收消息页面的地址 / *');
	this.contentWindow.postMessage("sss",'*');
}
```

```js
// http://www.B.com/b.html

// 通过 message 事件，监听对方发送过来的消息
window.addEventListener('message', function (e) {
	console.log(e.data);
  
  // e.source 相当于发送消息的窗口, 也就是http://www.A.com/a.html
	e.source.postMessage('Nice to see you!', '*');
}, false);
```



### window.name + iframe

**原理：**

**特点：**无论是否同源，只要在同一窗口的不同页面设置 `window.name`即可实现通信。

```js
> window.name
""

> window.name='test';
"test"

> location.href='http://www.baidu.com';
"http://www.baidu.com"

> window.name
"test"
```

**实现：**在当前页面动态创建一个<iframe>，将与服务同源的页面的地址赋值src属性；<iframe>加载完毕后，将与当前页面同源的代理页面的地址赋值给src属性。通过`this.contentWindow.name`访问<iframe>的`window.name`。

==`www.B.com` 域名下==

```js
/*
www.B.com/index.html 是一个与服务器同源的页面
将通过 ajax 获取的数据赋值给 window.name
*/
let xhr = new XMLHttpRequest();
xhr.open('POST', 'http://localhost:3000/post');

xhr.onload = function () {
    window.name = this.response;
}

xhr.send();
xhr = null; 
```

数据有了，window.name 也设置了，如何在不同源的情况下访问到？

这里就需要满足在同一窗口的这个条件了。

比如需要在`www.A.com/a.html`访问到`www.B.com/index.html`的数据，想要实现同一窗口，页面还不能发生跳转，因为`www.A.com/a.html`页面的操作未做完，就想那个数据。这样就需要借助一个`隐藏的iframe`来实现。

==`www.A.com` 域名下==

```js
// www.A.com/proxy.html 一个空的代理页面
```

```js
// www.A.com/a.html

// 动态创建一个 iframe，src 属性指向 www.B.com/index.html
let iframe = document.createElement('iframe');
iframe.src = 'www.B.com/index.html';
iframe.style.display = 'none'
body.appendChild(iframe);

iframe.onload = function () {
  // 这时 www.B.com/index.html 这个页面相当于放在了 iframe 里面了
  
  // 在 iframe 跳转到代理页面，实现不同页面同一窗口
  this.src = 'www.A.com/proxy.html';
  
  // 访问到 window.name 中数据
  console.log(this.contentWindow.name);
  
	body.removeChild;
}

```

想要获得数据需要在`iframe` 跳转到代理页面之后，所以需要监听第二次的 `iframe.onload` 

```js
let body = document.querySelector('body')
let iframe = document.createElement('iframe');
let state;

function submit() {
    state = 0;
    iframe.src = 'http://localhost:3000';
    iframe.style.display = 'none'
    body.appendChild(iframe);
}

iframe.onload = function () {
    if (state == 0) {
        iframe.src = 'http://localhost:4000/proxy'
        state = 1;
    } else {
        console.log(this.contentWindow.name);
        body.removeChild(document.querySelector('iframe'));
    }
}
```



使用 form 提交时，可以不用写服务端同源的页面，因为 form 会自动跳转，将 form target属行赋值给iframe就行了。

```js
// node 返回时拼接一个 script中的 window.name
server.post('/post', (req, res) => {
  res.send('<script>window.name="4000端口的数据"</script>');
})
```



### document.domain + iframe

**原理：**给两个不同的页面设置一个相同的主域，这样就实现同域了。

**特点：**这种方式==只适合主域名相同, 但子域名不同==的 `iframe` 和 `cookie`跨域

+ 主域名：`http://crossdomain.com:9099`
+ 子域名A：`http://A.crossdomain.com:9099`
+ 子域名B：`http://B.crossdomain.com:9099`

**实现：**

在A、B两个子域对应的页面添加 `document.domain = crossdomain.com`

**前端页面**

```html
<!-- 前端页面地址： http://localhost:4000/ -->

<form action="http://localhost:3000/post" method="post" target="targetIfr">
    <input type="submit" value="提交"></input>
</form>
<iframe name="targetIfr" style="display:none"></iframe>
```

```js
// 设置相同的主域
document.domain = "localhost";

let iframEl = document.querySelector('iframe');

iframEl.onload = function () {
    // 获取iframe的内容，即服务返回的数据
    let body = this.contentDocument.body || this.contentWindow.document.body;

    console.log(body.querySelector("p").textContent);
}
```

通过`form`表单提交，页面会跳转到 `http://localhost:3000/post`；

为了避免页面跳转可以将  `http://localhost:3000/post` 放入 `iframe` 中；

因为前端端口为 3000，后端端口为 4000，所以无法访问到 `iframe` 中的内容；

在端口 3000对应的页面添加 `document.domain`，端口 4000 对应的页面是`iframe`，所哟需要在后端返回中拼接。



**node后端**

```js
// 后端地址：http://localhost:3000/post

server.post('/post', (req, res) => {
  res.send('<p>后端返回信息</p> <script>document.domain = "localhost";</script>')
})
```



### location.hash + iframe

**原理：**利用`location.hash`来进行传值

**特点：**

**实现：**

```js
// http://www.A.com

// 创建一个 iframe，地址指向 http://www.B.com/b.html
let body = document.querySelector('body');
let iframe = document.createElement('iframe');

creatIframe();

function creatIframe() {
    iframe.src = 'http://www.B.com/b.html';
    iframe.style.display = 'none';
    body.appendChild(iframe);
}
```



### cors

**原理：**

**特点：**

**实现：**



### websocket

**原理：**

**特点：**

**实现：**



### nginx反向代理

**原理：**

**特点：**

**实现：**



### Node中间件代理(两次跨域)

**原理：**

**特点：**

**实现：**



