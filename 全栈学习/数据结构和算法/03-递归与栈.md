## 所发生的



## 面试算法题

### LeetCode03.04题 - 化栈为队

```js
// 1 - 用两个栈实现队列的操作
// 2 - 将每个值放入输入栈 pushStack = [1,2,3], 相当于入队操作
// 3 - 出队时, 将 pushStack  = [1,2,3] 中的数据倒序放入输出栈 popStack = [3,2,1], pushStack 满足了栈的先进后出的特性
// 4 - 然后从输出栈 popStack 中出栈, 也就是队列的出队操作, popStack = [3,2,1] ==> popStack = [3,2] , 同时 popStack 也符合栈的先进后出的特性

// 5 - pushStack  = [1,2,3] ==> popStack = [3,2,1] ==> 1 整体实现了队列的先进先出
```

```js
var MyQueue = function () {
    // 输入栈
    this.pushStack = [];
    // 输出栈
    this.popStack = [];
};

/**
 * Push element x to the back of queue. 
 * @param {number} x
 * @return {void}
 */
MyQueue.prototype.push = function (x) {
    // 入栈 （入队）
    this.pushStack.push(x);
};

/**
 * Removes the element from in front of queue and returns that element.
 * @return {number}
 */
MyQueue.prototype.pop = function () {
    // 如果输出栈为空，从输入栈导入
    // [1,2,3] --> [3,2,1]
    // 此过程实现了栈的先入后出
    if (!this.popStack.length) {
        while (this.pushStack.length) {
            this.popStack.push(this.pushStack.pop());
        }
    }
    // 出栈（出队）
    // 对于栈来说 popStack 实现了先入后出
    // 对于队列来说 pushStack = [1,2,3] --> popStack = [3,2,1] --> 实现了队列的先入先出
    return this.popStack.pop();
};

/**
 * Get the front element.
 * @return {number}
 */
MyQueue.prototype.peek = function () {
    if (!this.popStack.length) {
        while (this.pushStack.length) {
            this.popStack.push(this.pushStack.pop())
        }
    };
    let num = this.popStack.pop();
    this.popStack.push(num);
    return num;
}

/**
 * Returns whether the queue is empty.
 * @return {boolean}
 */
MyQueue.prototype.empty = function () {
    // 输入、输出栈都为空，证明这个队列是空的
    return !this.pushStack.length && !this.popStack.length;
};
```



### LeetCode682题 - 棒球比赛

```js
var calPoints = function (ops) {
    let result = [];
    for (let num of ops) {
        switch (num) {
            case 'C':
                result.pop();
                break;
            case 'D':
                result.push(result[result.length - 1] * 2);
                break;
            case '+':
                result.push(result[result.length - 1] + result[result.length - 2]);
                break;
            default:
                result.push(Number(num));
                break;
        }
    }
    return result.reduce((a, b) => a + b);
};
```



### LeetCode844题 - 比较含退格的字符串

```js
var backspaceCompare = function (S, T) {
    return processed(S) === processed(T);
};

// 去除空格
const processed = function (str) {
    const stack = [];
    for (let char of str) {
        if (char === '#') {
            stack.pop();
        } else {
            stack.push(char);
        }
    }
    return stack.join('');
}
```



### LeetCode946题 - 验证栈序列

```js
1 - 有一个新栈 
2 - 按照 pushed 中的顺序入栈
3 - 按照 popped 中的顺序出栈
4 - 返回 true, 否则返回 false
```

```js
var validateStackSequences = function (pushed, popped) {
    let stack = [], pre = 0;
    for (let i of pushed) {
        stack.push(i);
        // 每次入栈后，判断新栈 stack 中的最后一位是不是需要弹栈的
        // 如果是就弹出，指向 popped 的针后移一位
        while (stack.length && stack[stack.length - 1] == popped[pre]) {
            stack.pop();
            pre++;
        }
    }

    return !stack.length;
};
```



### LeetCode20题 - 有效括号

```js
1 - 左括号必须用相同类型的右括号闭合。
2 - 左括号必须以正确的顺序闭合。
'()'、'()[]{}' 为真
'(()'、'(])' 为假
```



```js
var isValid = function (s) {
    // 以为右边括号为 key，做一个映射
    let map = new Map([
        [')', '('],
        [']', '['],
        ['}', '{'],
    ]);

    let stack = [];

    for (let i of s) {

        // 1 - 栈不为空
        // 2 - 右括号匹配的左括号，在栈的最后一位
        // 3 - 栈为空，证明所有括号都能闭合
        if (stack.length && stack[stack.length - 1] == map.get(i)) {
            stack.pop();
        } else {
            stack.push(i);
        }
    }

    return !stack.length;
};
```



### LeetCode1249题 - 移除无效括号

```js
var minRemoveToMakeValid = function (s) {
    // leftDel 需要删除的 (;
    // rightDel 需要删除的 );
    const leftDel = [], rightDel = [];

    // 遍历字符串 s
    for (let i = 0; i < s.length; i++) {
        // 遇到 ( 存入到 leftDel;
        if (s[i] === '(') {
            leftDel.push(i);
        } else if (s[i] === ')') {
            // 遇到 ) 并且 leftDel有 ( 存在, 证明匹配, 从 leftDel 删除;
            if (leftDel.length) {
                leftDel.pop();
            } else {
                // 遇到 ) 并且 leftDel 不存在 (, 证明不匹配, 加入到 rightDel;
                rightDel.push(i);
            }
        }
    }

    // 将 s 转成数组res, 将需要删除的括号拼成一个数组 del;
    const res = [...s], del = [...leftDel, ...rightDel];

    // 从 s 中删除需要删除的括号
    for (let i = 0; i < del.length; i++) {
        res[del[i]] = '';
    }

    // res 转成字符串输出
    return res.join('');
};
```



### LeetCode1021题 - 删除最外层括号

```js
var removeOuterParentheses = function (S) {

    // differ 为出现括号的个数
    // 只有同一个括号出现两次或者两次以上,才能证明不是最外层
    let res = '', differ = 0;
    for (let char of S) {
        // if (char === '(') {
        //     differ++;
        //     if (differ > 1) res += char;
        // } else if (char === ')') {
        //     differ--;
        //     if (differ > 0) res += char;
        // }
        if (char === '(' && differ++ > 0) res += char;
        if (char === ')' && differ-- > 1) res += char;
    }
    return res;
};
```



### LeetCode145题 - 二叉树的后序遍历????????

```js
// 根据遍历根节点的顺序来决定是什么序遍历
// 前序遍历: 遍历子节点顺序为 根 - 左 - 右 
// 中序遍历: 遍历子节点顺序为 左 - 根 - 右
// 后序遍历: 遍历子节点顺序为 左 - 右 - 根
```

**递归实现**

```js
var postorderTraversal = function (root) {
    let res = [];
    return postorderTraversalNode(root, res);

};

const postorderTraversalNode = function (node, res) {
    if (node) {
        // 遍历左节点
        postorderTraversalNode(node.left, res);
        // 遍历右节点
        postorderTraversalNode(node.right, res);
        // 中间节点
        res.push(node.val);
    }
    return res;
}
```

**迭代实现????????**

```js
var postorderTraversal = function (root) {
    let res = [];
    if (!root) return res;
    const stack = [root];
    while (stack.length) {
        root = stack.pop();
        res.unshift(root.val);

        if (root.left) stack.push(root.left);
        if (root.right) stack.push(root.right);
    }
    return res;
};
```





### LeetCode331题 - 验证二叉树的前序序列化

![1616516562618](C:\Users\Amd\AppData\Roaming\Typora\typora-user-images\1616516562618.png)

![1616516883623](C:\Users\Amd\AppData\Roaming\Typora\typora-user-images\1616516883623.png)

![1616517067499](C:\Users\Amd\AppData\Roaming\Typora\typora-user-images\1616517067499.png)

![1616517249049](C:\Users\Amd\AppData\Roaming\Typora\typora-user-images\1616517249049.png)

![1616517399880](C:\Users\Amd\AppData\Roaming\Typora\typora-user-images\1616517399880.png)

![1616517437464](C:\Users\Amd\AppData\Roaming\Typora\typora-user-images\1616517437464.png)

```js
var isValidSerialization = function (preorder) {
    // stack 默认添加根节点
    const n = preorder.length, stack = [1];
    let i = 0;
    while (i < n) {
        if (!stack.length) return false;
        if (preorder[i] === ',') i++;
        else if (preorder[i] === '#') {
            stack[stack.length - 1]--;
            if (stack[stack.length - 1] === 0) {
                stack.pop();
            }
            i++;
        } else {
            while (i < n && preorder[i] !== ',') {
                i++;
            }
            stack[stack.length - 1]--;
            if (stack[stack.length - 1] === 0) {
                stack.pop();
            }
            stack.push(2);
        }
    }

    return !stack.length;
};
```



### LeetCode1021题 - 基本计算器II



### LeetCode1021题 - 函数的独占时间



### LeetCode1021题 - 表现良好的最长时间段