## 同步责任链

```js
function f1(ctx, next) {
    console.log('执行到f1')
    next()
    console.log('f1执行完毕')
}

function f2(ctx, next) {
    console.log('执行到f2')
    next()
    console.log('f2执行完毕')
}

function f3(ctx, next) {
    console.log('执行到f3')
    console.log('f3执行完毕')
}
```

```js
let next1 = function (ctx) {
    f1(ctx, next2)
}

let next2 = function (ctx) {
    f2(ctx, next3)
}

let next3 = function (ctx) {
    f3(ctx)
}

next1("ctx");

// 执行到f1
// 执行到f2
// 执行到f3
// f3执行完毕
// f2执行完毕
// f1执行完毕
```



## 一次性执行所有-同步

```js
function nextCompose(middle) {
    return function () {
        dispatch(0);
        function dispatch(i) {
            let fn = middle[i];
            if (!fn) {
                return;
            }

            fn('ctx', function () {
                dispatch(i + 1);
            })
        }
    }
}

const middle = [f1, f2, f3];
nextCompose(middle)();

// 执行到f1
// 执行到f2
// 执行到f3
// f3执行完毕
// f2执行完毕
// f1执行完毕
```



## 异步责任链

```js
async function f1(ctx, next) {
    console.log('执行到f1')

    await f2()

    console.log('f1执行完毕')
}

async function f2(ctx, next) {
    console.log('执行到f2')
    await new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve();
        }, 2000)
    })
    console.log('f2执行完毕')
}

f1()

// 执行到f1
// 执行到f2
// f2执行完毕
// f1执行完毕
```



+ 每个函数中都需要等下一个函数执行完毕 `await next()`

  所以每个函数都需要 Promise 返回一个承诺 , 告诉上一个函数我执行完毕

  ```js
  return Promise.resolve(
      fn('ctx', function () {
          dispatch(i + 1);
      })
  );
  
  // 执行到f1
  // 执行到f2
  // f1执行完毕
  // setTimeout
  // f2执行完毕
  ```

+ 结果与我们所期望的有些出入

  + 分析上述结果， f2 中setTimeout没有执行完毕就执行了 f1 后续代码。

    所以我们不能只执行当前函数，我们还需要将当前函中的其他异步函数执行承诺返回给上一个函数

    ```js
    function a() {
        return (function () {
            async function b() {
                await new Promise((resolve, reject) => {
                    setTimeout(() => {
                        resolve();
                    }, 2000)
                })
            }
            b();
        })()
    }
    
    console.log(a()); // undefined
    
    // 以下结果返回一个执行承诺
    // await new Promise((resolve, reject) => {
  //     setTimeout(() => {
    //         resolve();
    //     }, 2000)
    // })
    
  // 如果 await b() 想要得到这个执行承诺，需要将这个执行承诺 return
    ```

    ```js
    return b()
    console.log(a()); // Promise { <pending> }
    ```
  
  + 因此得出结论
  
      ```JS
      return Promise.resolve(
          fn('ctx', function () {
              return dispatch(i + 1);
          })
      )
      
      // 执行到f1
      // 执行到f2
      // setTimeout
      // f2执行完毕
      // f1执行完毕
      ```
    
  + 总结： 
  
      当一个执行承诺中存在异步函数，我们需要将这个异步函数的执行承诺一直 return 到这个执行承诺中
  
      

## 一次性执行所有 - 异步

```js
async function f1(ctx, next) {
    console.log('执行到f1')
    await next()
    console.log('f1执行完毕')
}

async function f2(ctx, next) {
    console.log('执行到f2')
    await new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve();
        }, 2000)
    })
    await next();
    console.log('f2执行完毕')
}

function f3(ctx, next) {
    console.log('执行到f3')
    console.log('f3执行完毕')
}

function nextCompose(middle) {
    return function () {
        dispatch(0);
        function dispatch(i) {
            let fn = middle[i];
            if (!fn) {
                return;
            }

            return Promise.resolve(
                fn('ctx', function () {
                    return dispatch(i + 1);
                })
            );
        }
    }
}

const middle = [f1, f2, f3];
nextCompose(middle)();
```

