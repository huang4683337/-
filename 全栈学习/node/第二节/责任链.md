## 同步责任链

```js
function f1(ctx, next) {
    console.log('执行到f1')
    next()
    console.log('f1执行完毕')
}

function f2(ctx, next) {
    console.log('执行到f2')
    next()
    console.log('f2执行完毕')
}

function f3(ctx, next) {
    console.log('执行到f3')
    console.log('f3执行完毕')
}
```

```js
let next1 = function (ctx) {
    f1(ctx, next2)
}

let next2 = function (ctx) {
    f2(ctx, next3)
}

let next3 = function (ctx) {
    f3(ctx)
}

next1("ctx");

// 执行到f1
// 执行到f2
// 执行到f3
// f3执行完毕
// f2执行完毕
// f1执行完毕
```



## 一次性执行所有

```js
function nextCompose(middle) {
    return function () {
        dispatch(0);
        function dispatch(i) {
            let fn = middle[i];
            if (!fn) {
                return;
            }

            fn('ctx', function () {
                dispatch(i + 1);
            })
        }
    }
}

const middle = [f1, f2, f3];
nextCompose(middle)();

// 执行到f1
// 执行到f2
// 执行到f3
// f3执行完毕
// f2执行完毕
// f1执行完毕
```



## 异步责任链

```js
// 修改 f2 方法
async function f2(ctx, next) {
    console.log('执行到f2')
    await new Promise((resolve,reject)=>{
        setTimeout(()=>{
            resolve();
        },2000)
    })
    await next()
    console.log('f2执行完毕')
}

// 执行到f1
// 执行到f2
// f1执行完毕
// 执行到f3
// f3执行完毕
// f2执行完毕
```

**以上结果与我们预期的 123 ===> 321 不同**

原因是：使用 async  await 时，await 后面的必须是一个 Promise 执行承诺



```js
function nextCompose(middle) {
    return function () {
        dispatch(0);
        function dispatch(i) {
            let fn = middle[i];
            if (!fn) {
                return;
            }
            return Promise.resolve(
                fn('ctx', function () {
                   return dispatch(i + 1);
                })
            );
        }
    }
}
```

