## 1、工厂模式

> 解决重复代码的书写

```js
function createPerson(name, age, job) {
    let o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function () {
        console.log(this.name);
    }
    return o;
}

let person1 = createPerson('tom', 18, 'Software Engineer');
let person2 = createPerson('ming', 98, 'Doctor');

person1.sayName();
person2.sayName();
```

```
优点：解决创建多个类似对象的问题
```

```js
// 缺点：没有解决对象标识问题。只能鉴别出是 Object 类型，不能鉴别出属于哪个实例
console.log(typeof person1); // Object
console.log(person1 instanceof createPerson); // false
```





## 2、构造函数模式

```js
function Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function () {
        console.log(this.name);
    }
}

let person1 = new Person('tom', 18, 'Software Engineer');
let person2 = new Person('ming', 98, 'Doctor');

person1.sayName();
person2.sayName();
```

```
相对于工厂模式
- 没有显示创建对象
- 属性和方法直接赋值给 this
- 没有 return
```

```js
// 解决了对象标识
console.log(person1 instanceof Object); // true
console.log(person1 instanceof Person); // true
```



### 提取构造函数内部方法

构造函数内部写方法时，每次 new 初始化时，都会创建一个 sayNmae 方法。

```js
console.log(person1.sayName == person2.sayName); 
// false
```

```js
function Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = sayName;
}


function sayName() {
    console.log(this.name);
}

console.log(person1.sayName == person2.sayName);
// true
```

```
缺点：
- 全局定义方法造成全局作用域的混乱
- 全局定义的方法不能很好的聚在一起，不知道属于谁
```





### new 操作符做了什么

+ 在内存中创建一个对象
+ 这个新对象内部的 `[[prototype]]`  特性被赋值为构造函数的 `prototype` 属性
+ 构造函数内部的 `this` 指向新对象
+ 执行构造函数内部代码，给新对象添加属性、方法
+ 返回构造函数非空对象 | 刚创建的新对象



## 3、原型模式

```js
let Person = function () { };

Person.prototype.name = 'tom';
Person.prototype.age = 18;
Person.prototype.job = 'Docter';
Person.prototype.sayName = function () {
    console.log(this.name);
};

const person1 = new Person();
const person2 = new Person();
```

所有的属性和方法都添加到 Person 的 prototype 上，构造函数体什么也没有 。

原型上定义的属性和方法是共享的。

```js
console.log(person1.sayName == person2.sayName);
// true
```



### 理解原型

+ 无论何时，只要创建一个函数 ，就会为这个函数创建一个 `prototype` 属性，（这个属性指向原型对象）
+ 所有的原型对象自动获取一个 `constructor`  属性，指向关联的构造函数

```js
let Person = function () { };
console.log(Person.prototype.constructor);
// [Function: Person]
```

+ 原型对象继承自 `Object`

  Firefox、Safari、Chrome会在对象上通过`__proto__` 属性暴露对象的`[[prototype]]`属性，通过 `__proto__` 属性可以访问对象的原型。

```js
console.log(Person.prototype.__proto__);
// [Object: null prototype] {}
```

+ `Object` 的原型指向 `null`

```js
console.log(Person.prototype.__proto__.__proto__);
// null
```

+ 实例的原型对象指向构造函数的原型对象

  实例是 new 出来的一个对象

```js
let Person = function () { };
Person.prototype.name = 'tom';

const person1 = new Person();

console.log(person1.__proto__);
// { name: 'tom' }

console.log(person1.__proto__ === Person.prototype);
// true
```

> 实例和构造函数的原型有直接关系：实例对象的 `__proto__` 继承自构造函数的 原型对象。
>
> 实例和构造函数之间没有直接关系。



#### isPrototypeOf

```
aaa 是 bbb 的原型对象吗
```

```js
let Person = function () { };
Person.prototype.name = 'tom';

const person1 = new Person();

console.log(Person.prototype.isPrototypeOf(person1));
// true
// Person.prototype（Person 的原型对象）是 person1 的原型对象
```



#### getPrototypeOf

```
aaa 的原型对象是谁？
```

```js
let Person = function () { };
Person.prototype.name = 'tom';

const person1 = new Person();

console.log(Object.getPrototypeOf(person1));
// { name: 'tom' }

console.log(Object.getPrototypeOf(person1) === Person.prototype);
// person1 的原型对象 是 Person.prototype（Person的原型对象） 
```



#### setPrototypeOf

> 修改对象的原型继承关系，不推荐

将 biped 设置为 person 的原型对象

```js
const person = {
    name: 'tom'
}

const biped = {
    numLegs: 2
}

Object.setPrototypeOf(person, biped)

console.log(person.name);   // tom
console.log(person.numLegs);    // 2

console.log(Object.getPrototypeOf(person) === biped);
// true
```



#### Object.create

> 通过 xx 创建一个新的对象，将 xx 指定为新的对象的原型对象

```js
const biped = {
    numLegs: 2
}

const person = Object.create(biped);

console.log(person.numLegs);    // 2

console.log(Object.getPrototypeOf(person) === biped);
// true
```



### 原型层级

可以读取原型上的值，但是不能重写原型上的值。

如果在当前实例修改某属性，这个属性会遮住原型上的属性，但不会影响其它实例。

```js
const Person = function () { };

Person.prototype.name = 'tom';
Person.prototype.obj = { a: 'Person' };

const person1 = new Person();
const person2 = new Person();

person1.name = 'person_1_name';
person1.obj = { b: 'person1' };

console.log(person1.name);  // person_1_name
console.log(person2.name);  // tom

console.log(person1.obj);   // { b: 'person1' }
console.log(person2.obj);   // { a: 'Person' }
```

`person1.name` 的值来自于实例。

`person2.name` 的值来自于原型。



只要原型上存在的属性，被修改过，就无法访问到原型上的值。

可以使用 `delete`  删除实例上的这个属性，让实例去访问原型。

```js
const Person = function () { };

Person.prototype.name = 'tom';

const person1 = new Person();
const person2 = new Person();

person1.name = 'person_1_name';

// delete 删除实例上的 name 属性
// 让实例 person1 去原型上访问 name 属性
delete person1.name;

console.log(person1.name);  // tom
console.log(person2.name);  // tom
```



#### hasOwnPrototype

```
确定某个属性在原型上，还是在实例上
这个方法是继承自 Object 上

实例.hasOwnPrototype(属性)
- 在实例上，就返回 true
- 在圆拱形对象上就返回 false
```

```js
const Person = function () { };

Person.prototype.name = 'tom';

const person1 = new Person();
const person2 = new Person();

person1.name = 'person_1_name';


console.log(person1.hasOwnProperty(name));  // true 
console.log(person2.hasOwnProperty(name));  // false
```

`person1.name` 访问的是实例 `person1` 上的属性。

`person2.name` 访问的是 `Person`  原型对象上的属性。



#### in 操作符

```
确定是否可以访问到某个属性
- 访问的是实例对象和原型对象上的属性
```

```js
const Person = function () { };

Person.prototype.name = 'tom';

const person1 = new Person();
const person2 = new Person();

person1.name = 'person_1_name';


console.log('name' in person1);  // true 
console.log('name' in person2);  // true
```

可以在实例 `person1` 上访问到属性 name

可以在 `person2` 的原型对象上访问到属性 name



#### for...in

> 遍历的是对象上所有的属性（包括实例属性、原型属性）
>
> 开发者定义的不可枚举的属性也会遍历。



#### Object.keys

> 注意：开发者定义的属性都默认为可枚举。

> 只能访问到当前对象上的可枚举的属性属性。
>
> 返回一个符合条件的数组

```js
const Person = function () { };

Person.prototype.name = 'tom';
Person.prototype.age = 18;

const person1 = new Person();
const person2 = new Person();

person1.name = 'person_1_name';


console.log(Object.keys(person1));  // [ 'name' ]
console.log(Object.keys(person2));  // []
console.log(Object.keys(Person.prototype)); 
// [ 'name', 'age' ]
```

`person1` 实例上可枚举的属性 `name` 

`person2` 实例上没有可枚举的属性

`Person.prototype` (Person的原型对象上) 可枚举属性 `name、age`



#### getOwnProoertyNames

> 当前对象上的所有属性 （ 包括非开发人员定义的不可枚举属性 ）

```js
const Person = function () { };

Person.prototype.name = 'tom';
Person.prototype.age = 18;

const person1 = new Person();
const person2 = new Person();

person1.name = 'person_1_name';


console.log(Object.getOwnPropertyNames(person1));
// ['name']
console.log(Object.getOwnPropertyNames(person2));
// []
console.log(Object.getOwnPropertyNames(Person));
// [‘constructor’,'name','age']
```

非开发人员定义的不可枚举属性 `constructor`



#### getOwnPropertySymbols

> 与 `Object.getOwnProoertyNames` 类似。
>
> 只不过用来处理新的数据类型 symbols



#### 属性枚举的顺序





## 4、对象迭代

### 其它原型语法

开发过程中，喜欢把所有的属性一次性的挂载到构造函数的原型上

```js
const Person = function () { };

Person.prototype = {
    name: 'tom',
    age: 18
}

const person1 = new Person();

console.log(person1.constructor);
// [Function: Object]
```

这样会导致实例的 `constructor` 属性指向 `object`，需要重写  `constructor` 属性

```js
Person.prototype = {
    constructor: Person,
    name: 'tom',
    age: 18
}
```

```js
// 或者添加描述，不可枚举的 constructor
Object.defineProperty(Person.prototype, 'construtor', {
    enumerable: false,
    value: Person
})
```



### 原型的动态性

创建实例后，对原型添加方法、或者属性，实例可以访问到。

```js
const Person = function () { };

Person.prototype.name = 'tom'

const person1 = new Person();

Person.prototype.sayName = function () {
    console.log(this.name);
}

person1.sayName();
// tom
```

创建实例后，重写原型，会导致实例无法访问到新定义的。因为实例的原型是一个指针，重写构造函数原型不会影响到之前定义的。

```js
const Person = function () { };

Person.prototype.name = 'tom'

const person1 = new Person();

Person.prototype = {
    sayName: function () {
        console.log(this.name);
    }
}

person1.sayName();
// person1.sayName is not a function
```



## 原型的问题

```js
const Person = function () { };

Person.prototype.arr = [1, 2, 3];

const person1 = new Person();
const person2 = new Person();

person1.arr.push(9)

console.log(person1.arr);
console.log(person2.arr);
```

原型上引用属性是共享的，如果自己的实例想要有副本，就需要其它的处理方式了

