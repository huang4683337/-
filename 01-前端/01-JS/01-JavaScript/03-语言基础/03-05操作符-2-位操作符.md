## 位操作符

ECMAScript 12 中的所有数值都以 IEEE 754 64 位格式存储，但位操作并不直接应用到 64 位表示，而是先把值转换为32 位整数，再进行位操作，之后再把结果转换为 64 位。

> 因为以上操作方式的原因导致特殊值 NaN 和 Infinity 在位操作中都会被当成 0 处理

> 从右向左，第32位（最后一位）代表符号，正或者负



**正数**

```js
// 18
// 存储格式
0000 0000 0000 0000 0000 0000 0001 0010

// 有效值
1 0010
```



**负数**

```js
// 负数以二进制的补码的形式进行存储

//-18
// 先得到 18 的二进制表示
0000 0000 0000 0000 0000 0000 0001 0010
// 求出反码：0、1互换
1111 1111 1111 1111 1111 1111 1110 1101
// 反码 +1
1111 1111 1111 1111 1111 1111 1110 1110
```



## 按位非 ~

+ 使用 `~` 表示
+ 返回数值的补数 *(负数)*

```js
let num1 = 25; // 二进制00000000000000000000000000011001 
let num2 = ~num1; // 二进制11111111111111111111111111100110 console.log(num2); // -26
```



## 按位与 &

+ 使用 `&` 表示
+ 将两个数的*二进制数*每一位对齐，进行以下操作。两个位都是 1时，返回 1；其他情况返回 0。

| 第 1 个二进制数的位对应的数 | 第 2 个二进制数的位对应的数 | 结果 |
| --------------------------- | --------------------------- | ---- |
| 1                           | 1                           | 1    |
| 1                           | 0                           | 0    |
| 0                           | 1                           | 0    |
| 0                           | 0                           | 0    |



```js
let result = 25 & 3; 
console.log(result); // 1

25  = 0000 0000 0000 0000 0000 0000 0001 1001 
3   = 0000 0000 0000 0000 0000 0000 0000 0011 
--------------------------------------------- 
AND = 0000 0000 0000 0000 0000 0000 0000 0001
```



## 按位或 |

+ 使用 `|` 表示

+ 将两个数的*二进制数*每一位对齐，进行以下操作。至少有一位为 1 时，返回 1；两位为 0 时返回 0。

| 第 1 个二进制数的位对应的数 | 第 2 个二进制数的位对应的数 | 结果 |
| --------------------------- | --------------------------- | ---- |
| 1                           | 1                           | 1    |
| 1                           | 0                           | 1    |
| 0                           | 1                           | 1    |
| 0                           | 0                           | 0    |

```js
let result = 25 | 3; 
console.log(result); // 27

25  = 0000 0000 0000 0000 0000 0000 0001 1001 
3   = 0000 0000 0000 0000 0000 0000 0000 0011 
--------------------------------------------- 
OR  = 0000 0000 0000 0000 0000 0000 0001 1011
```



## 按位异或 ^

+ 使用 `^` 表示

+ 将两个数的*二进制数*每一位对齐，进行以下操作。只有一位为 1 时，返回 1；其他 情况返回 0。

| 第 1 个二进制数的位对应的数 | 第 2 个二进制数的位对应的数 | 结果 |
| --------------------------- | --------------------------- | ---- |
| 1                           | 1                           | 0    |
| 1                           | 0                           | 1    |
| 0                           | 1                           | 1    |
| 0                           | 0                           | 0    |

```js
let result = 25 ^ 3; 
console.log(result); // 26

25  = 0000 0000 0000 0000 0000 0000 0001 1001 
3   = 0000 0000 0000 0000 0000 0000 0000 0011 
--------------------------------------------- 
XOR = 0000 0000 0000 0000 0000 0000 0001 1010
```



## 左移 <<

+ 使用 `<<` 表示

+ 按照指定的位数将数值的所有位向左移动

```js
// 比如，如果数 值 2(二进制 10)向左移 5 位，就会得到 64(二进制 1000000)

let oldValue = 2; // 等于二进制 10
let newValue = oldValue << 5; // 做移 5 位，等于二进制 1000000，即十进制 64

2  = 0000 0000 0000 0000 0000 0000 0000 0010
		 |
   符号位
64 = 0000 0000 0000 0000 0000 0000 0100 0000
																			|	||||
  																		左移后空的位置用 0 补
```



> 左移之后，右边空下的位置用 0 来表示
>
> 左移会保留它所操作数值的符号，比如，如果 -2 左移 5 位，将得到 -64，而不是正 64。



## 有符号右移 >>

+  使用 `>>` 表示

+ 会将数值的所有 32 位都向右移，*同时保留符号(正或负)*

有符号右移其实是左移的逆运算。

```js
// 如果将 64 右移 5 位，那就是 2

let oldValue = 64; // 等于二进制1000000
let newValue = oldValue >> 5; // 等于二进制10，即十进制2


64 = 0000 0000 0000 0000 0000 0000 0100 0000
     |
    符号位
2  = 0000 0000 0000 0000 0000 0000 0000 0010
			||| ||
      右移之后使用 0，来补充空位
```



## 无符号右移

+  使用 `>>>` 表示
+ 会将数值的所有 32 位都向右移



**对于正数，无符号右移与 有符号右移结果相同**

```js
let oldValue = 64; // 等于二进制1000000
let newValue = oldValue >>> 5; // 等于二进制10，即十进制2
```



**对于负数，有时候差异会非常大。与有符号右移不同，无符号右移会给空位补 0，而不管符号位是什么**。

无符号又移，会将符号位当作一个值来处理。

因为负数是按照其绝对值的二进制的补码来进行存储的，所以在右移之后结果变化非常大。

```js
let oldValue = -64; // 等于二进制11111111111111111111111111000000 
let newValue = oldValue >>> 5; // 等于十进制 134217726

-64  = 1111 1111 1111 1111 1111 1111 1100 0000 
>>>5 = 0000 0111 1111 1111 1111 1111 1111 1110
```

