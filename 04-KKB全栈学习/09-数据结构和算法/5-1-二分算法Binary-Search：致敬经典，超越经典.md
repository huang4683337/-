## 二分算法

**二分算法就是一直在缩小查找区间，保证待查找值一定在这个区间范围内**



## 什么是二分查找

有序数组中查找 x 是否存在，如果存在返回存在位置

```
挨个顺序查找，时间复杂度为 O(n)
```





![1623329011640](C:\Users\Amd\AppData\Roaming\Typora\typora-user-images\1623329011640.png)

```
- min,max 代表查找区间
- 不断缩小查找区间来确定值
```

```
- 如果 arr[mid] = x, 找到结果
- 如果 arr[mid] < x, 查找区间为 arr[mid+1] 到 arr[max]
- 如果 arr[mid] < x, 查找区间为 arr[min] 到 arr[mid-1]
```

```
- 一次查找，就将查找区间缩小了一半
- 经过 log(n) 次，比较，最终查找区间剩下一个元素（min,max,mid）指向同一位置
```





## 二分查找-泛型情况

![1623329958578](C:\Users\Amd\AppData\Roaming\Typora\typora-user-images\1623329958578.png)

```
- 第一行：查找第一个 1
- 第二行：查找最后一个1
	- 1和0互换后，查找第一个 1 的前一位
```

**归根结底就是第一行查找的变种**

```
- 希望头尾指针指向第一个 1 的位置
- 面对前面一堆0，后面一堆1的情况，如何调整
	- 假设 mid 指向 1 时，第一个 1 在前半部分，或者 mid 
	- 因为 mid 指向的可能是 1
	- 所以调整尾指针 tail 时，要指向 mid 位置
	
	- 假设 mid 指向 0 时，第一个 1 一定在后半部分，
	- 因为 mid 不可能指向 0
	- 所以调整头指针 head 时，head 指向 mid + 1
```



**有序数组中，查找第一个大于等于9的数字**

```
- [5,7,9,9,9,10,10,11,15,20]
- 将小于9的标记为0，大于9的标记为1
- [0,0,1,1,1,1,1,1,1,1]
- 就是查找第一个 1
```



**思维转化，0代表条件不成立，1代表条件成立**

