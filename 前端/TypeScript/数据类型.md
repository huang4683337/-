

## String

### String

```js
let a: string = '123';

// 模板字符串
let sentence: string = `Hello, my name is ${a}`;
```



## Number

```js
let a: number = 123;
```



## Boolean

```js
let a: boolean = false;
let a: boolean = Boolean(1);

// 注意使用 构造函数 创造出来的是一个对象，不是一个布尔值
let a: boolean = new Boolean(1);
```



## 空值

可用于函数中表示没有任何反回值的函数

```js
function sum(): void {
	console.log('如果void函数中return就会报错');
}
```

```js
let a: void = undefined | null;

// void 类型的变量只能 将他赋值为 undefined 和 null
```



## Null 和 Undefined

`null`和`undefined` 是所有类型的子类型。 这两个类型的值，可以复制给其他类型。

```js
let a: string = undefined;
let b: number = undefined;
let c: boolean = undefined;

let d: string = null;
let e: number = null;
let f: boolean = null;
```



## 数组数据类型

```js
// 定义一个数组，类型是Number。意思就是数组中的成员只能是数字。
let arr: number[];
arr = [1,2,3];
arr = ['a'];	// Type 'string' is not assignable to type 'number'

// 定义一个数组，类型是 any。意思就是数组中的成员可以是任何类型。
let arr: any[] = [1,'2',{a:'3'}]
```



## 任意值 any

允许被赋值任何类型的值。

```js
let a: any;
```

> 没有声明类型 并且没有被赋值的类型， 默认为any 类型

```js
let something;
something = 'seven';
something = 7;
```



## 类型推断

> 没有声明数据类型，但是对具有初始值。
>
> ts会推断变量的类型就是初始值的类型

```js
let str = '123';
str = true; // 报错 Type 'true' is not assignable to type 'string'

/*
第一次进行变量赋值时，没有定义变量str的类型，但是给 str 的值是一个 String 类型的。
这样 ts 就推断你给这个变量定义的就是 String 类型
当将 true 赋值给 str 时，因为类型不匹配 所以报错
*/
```



## 联合类型

用来表示两个或者两个以上的数据类型的联合。 使用符号为 `|`

```js
// 定义参数 union 的数据类型为 number 或者 string
let union: number | string;

union = 1233;
union = '1233';
union = [1,2,3];	// Type 'number[]' is not assignable to type 'string'
```

### 访问联合类型的属性和方法

当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们**只能访问此联合类型的所有类型里共有的属性或方法**：

```js
function getLength(something: string | number): number {
    return something.length;
}

// 报错 是因为 length 不是number和string两者共有属性

// 如果 return something.toString(); 就不会
```



## 对象的类型：接口Interfaces

通过 `interface`定义一个对象的接口。

用来约束对象类型的属性，不能自己添加接口中没有的属性，接口中存在的属性也不能不写。

```js
interface Person{
  name: string;
  age: number;
}
// 定义一个接口 Person ，接口中只能存在 name 和 age 属性并且都是必填

let obj: Person = {
    name:'name',
    age:18,
}

console.log(obj); // { name: 'name', age: 18 }
```

### 可选属性

定义时在属性后面跟上`？`

```js
// age 是一个可选属性，所以在定义类型时可以不用
interface Person {
    name: string;
    age?: number;
}

let obj: Person = {
    name:'name',
}

console.log(obj);	// { name: 'name' }
```

### 任意属性

> 注意任意类型定义的数据类型必须是在这个接口中已经定义的。
>
> 下面接口中定义了 string类型的name 和 number类型的age，所以任意类型只能在 string和number中选择

```js
interface Person {
    name: string;
    age?: number;
    [propName: string]: any;
}

let obj: Person = {
    name: 'name',
    age:18,
    s:'s',
}

console.log(obj);	// { name: 'name', age: 18, s: 's' }
```



### 只读属性

使用 `readonly`关键字定义只读属性

**注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候**

```js
interface Person {
    name: string;
}

let obj: Person = {
    readonly name: 'name',		// 通过定义的接口 给属性赋值
}

console.log(obj);		// {name:'name'}

obj.name = 'ssss';	// 给对象赋值时，报错
```



## 数组类型

`elementType:[]` 表述数组的类型

```js
// 定义一个 number 类型的数组。成员只能是 number类型
let arr: number[] = [1,3,4,5];	

arr.push('sfsfsf');	// 给数组添加一个 string 类型的成员。  报错
```

**也可以使用数组泛型来表示数组**

###  数组泛型

```js
let fibonacci: Array<number> = [1, 1, 2, 3, 5];
```



##  函数类型

```js
// void 定义没有返回值的函数
function sun(): void { console.log('我没有返回值') }

// 返回值为number类型的函数
function sun(): number { return 1 }
```



### 用接口定义函数的形状

```js
// 接口定义函数形状：参数为number类型，函数是 boolean 类型
interface FnType {
    (source: number, subString: number): boolean;
}

// 接口赋值给函数名
let booleanFn: FnType;

// 写函数
booleanFn = function (source: number, subString: number) {
    return source > subString;
}

console.log(booleanFn(1, 3));  // false
```

### 函数的可选参数及默认值

+ 可选参数后面不能再跟必写参数 :`?`
+ 如果某个参数给了默认值，那么这参数就是默认为可选参数，并且参数后可以跟必写参数。

```js
// 定义可选参数
function sum(a: number, b?: string) { }

// 参数默认值
function sum(a: number=1, b: string) { }

sum(undefined,'2')
```

### rest 剩余参数

+ 可以接收任何数量的参数
+ 类似于 arguments

```js
// 接收数字类型的一个或多个参数
function rest(...arr:number[]){
    arr.forEach(item=>{
        console.log(item);
    })
}

rest(9);	// 9
rest(1,2,3,4,5);	// 1 2 3 4 5
```

### 函数重载

不同类型的参数调用同一个函数。

+ 定义函数需要使用的参数类型, 以及函数的类型
+ 定义执行函数体 函数以及参数类型为 any

```js
// 定义函数需要使用的参数类型, 以及函数的类型
function add(a: number, b: number): number;
function add(a: string, b: string): string;

// 定义执行函数体 函数以及参数类型为 any
function add(a: any, b: any): any{
    return a+b;
};

console.log( add(1,2) );    // 3
console.log( add('1','2') );    // 12
```

#### 

## 类型断言

类型断言（Type Assertion）可以用来手动指定一个值的类型。

> 语法： <类型>值   或者    值 as 类型
>
> 断言的类型必须是联合类型中存在的，不存在的是不能进行断言的。

```js
function sum(a: string | number): number {
    console.log(a.length);	// 报错
}
// 报错是因为 number 类型没有 length 方法
```

```js
function sum(a: string | number): void {
    if( (a as string).length ){	// 如果是 string 类型
        console.log( (a as string).length );
    }else{
        console.log('这是一个number类型');
    }
}

sum(1);	// 这是一个number类型
sum('22');	// 2
```



## 类型别名

可以通过`type`关键字来定义类型的别名。

**主要用于`联合类型`的命名。**

```js
type strNum = number | string;

let a: strNum; 

a= 1;
a= '22';
```



## 字符串字面量类型

字符串字面量类型用来约束取值只能是已经定义字符串中的一个

```js
type eventName = 'click' | 'mousemove' | 'mousedowm';

function handleEvent( event: eventName ){
}

handleEvent('click');

handleEvent('a');	// 报错 a 不是 eventName 定义的值
```



## 元组

用来存放不同类型的对象

```js
// 定义数组tom，存放 string number 类型。 初始化时，值和定义的类型必须一一对应
let arr: [string, number] = ['ss', 2];

// 向数组中添加的数据必须死已经定义的类型。
arr.push('11');
arr.push(22);
arr.push(true);	// 报错， 因为定义的类型不存在boolean
```



## 枚举类型 enum

通过`enum`定义一个枚举

```js
enum sex {
    '男',
    '女',
    '妖'
}

console.log(sex[0]);  // 男
console.log(sex['男']);	// 0
console.log(sex);	// { '0': '男', '1': '女', '2': '妖', '男': 0, '女': 1, '妖': 2 }
```



### 常量枚举

```js
const enum sex {
    '男',
    '女',
    '妖'
}

console.log(sex['男']); // 0 
```



### 外部枚举

是使用 `declare enum` 定义的枚举类型：

```js

```



## 类和接口

### 类实现接口





## 泛型

+ 定义函数、接口、类时
+ 不先指定具体类型
+ 使用时再指定具体的类型



