# 变量的解构赋值

## 数组的解构赋值

> 数据结构对应,  按照顺序给对应的值赋值

### 基本写法

```js
// 要求两边的数据结构必须一致
let[a,b,c] = [1,2,3];	// a => 1;  b => 2; c => 3;
let[,,c] = [1,2,3];	 	// c => 3; 
let [foo, [[bar], baz]] = [1, [[2], 3]];	// foo => 1;  bar => 2; baz => 3;
```

### 展开操作符 ...

```js
let[...a] = [1,2,3];	// a => [1,2,3]

// ... 获得到的赋值默认为数组 如果没有值 就对应空数组
let[a,b,...c] = [1];	// a => 1; b => undefined; c => []; 
```

### 不完全解构

```js
let [x, y] = [1, 2, 3];	// x => 1; y => 2;
```



### 默认值

```js
let [a = true] = [];	// a => true;
let [x, y = 'b'] = ['a']; // x='a', y='b'
let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'
// undefined 是无法给到别人的 ;  null 可以
```



>赋值优先 : 如果等号右边有对应的值, 优先将右边的值赋值给左边对应的项 
>
>从左至右 : 赋值完毕后, 左边的解构从左至右再进行处理

```js
function f() {
  console.log('aaa');
}

let [x = f()] = [1];	// x => 1


function f() {
  return 'aa';
}

let [x = f()] = [1];	// x => 1


function f() {
  return 'aa';
}

let [x = f()] = [];	// x => aa
```

```js
let [x = 1, y = x] = [];     // x=1; y=1
let [x = 1, y = x] = [2];    // x=2; y=2
let [x = 1, y = x] = [1, 2]; // x=1; y=2
let [x = y, y = 1] = [];     // ReferenceError: y is not defined; 左边结构从左至右对x赋值时 y还没定义
```



## 对象的解构赋值

> 对已经声明的变量赋值必须要用 （） 否则会被 js 认为是一个代码块

### 基本写法

> 找到与属性名一致的变量名,  将属性对应的值赋值给变量

```js
let {a,b} = {a:'aaa',b:'bbb'};		// a = 'aaa'; b = 'bbb'

let {c} = {d:'dd'};	// d => undefined
```

### 将对象方法赋值给变量

``` js
let { log, sin, cos } = Math;	// 将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上
const {log} = console;	// console.log赋值到log变量
log('hell');	// hell
```

### 变量名和属性名不一致

> 找到和对象属性名相同的变量(a),  将值赋给变量(a)对应的变量(c)

```js
let {a:c} = {a:'aaa'};	// a => a is not defined ; c => 'aaa' ;
```

### 嵌套结构的赋值

```js
let obj = {
  p: [
    'Hello',
    { y: 'World' }
  ]
};

let { p: [x, { y }] } = obj;			// p 代表的是模式
x // "Hello"
y // "World"


let { p, p: [x, { y }] } = obj;		// p 是一个变量
x // "Hello"
y // "World"
p // ["Hello", {y: "World"}]
```

```js
// 对已经声明的变量赋值必须要用 （） 否则会被 js 认为是一个代码块 
let obj = {};
let arr = [];

({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });

obj // {prop:123}
arr // [true]
```



### 默认值

```js
var {x = 3} = {};	// x => 3

var {x, y = 5} = {x: 1};	// x => 1; y => 5

var {x: y = 3} = {};	// y => 3

var {x: y = 3} = {x: 5};	// y => 5

var { message: msg = 'Something went wrong' } = {};		// msg => "Something went wrong"


// undefined 代表没有值 null 代表空的值
var {x = 3} = {x: undefined};		// x => 3

var {x = 3} = {x: null};	// x => null
```



### 注意

```js
({} = [true, false]);		// 这样是有效的 虽然没有任何意义

// 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构
let arr = [1, 2, 3];
let {0 : first, [arr.length - 1] : last} = arr;
first // 1
last // 3
```



## 字符串的解构赋值

> 字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象

```js
const [a, b, c, d, e] = 'hello';	// a=>'h'; b=>'e'; c=>'l'; d=>'l'; e=>'o';
```

> 类似数组的对象都有一个`length`属性，因此还可以对这个属性解构赋值

```js
let {length : len} = 'hello';		// len=>5 字符串长度
```



## 数值和布尔值的解构赋值

```js
let {toString: s} = 123;
s === Number.prototype.toString // true

let {toString: s} = true;
s === Boolean.prototype.toString // true
```



> 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象

```js
// 由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错
let { prop: x } = undefined; // TypeError
let { prop: y } = null; // TypeError
```



## 函数参数的解构赋值

```js
function add([x, y]){
  return x + y;
}

add([1, 2]); // 3
```



### 默认值

```js
function move({x = 0, y = 0} = {}) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, 0]
move({}); // [0, 0]
move(); // [0, 0]
```



> 

```js
function move({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, undefined]
move({}); // [undefined, undefined]
move(); // [0, 0]

```

