## 1、Js中的对象

+ 对象是单个实物的抽象

+ 对象是一个容器，封装了==属性==和==方法==，一切具有属性和方法的事物。

  - 属性，就是对象的一种特征
    - (静态的-比如名词)。比如年龄、姓名等。

  - 方法，就是对象的一种行为
    - 行为，是动态(动词)。比如吃饭、睡觉等。

一个人、一本书、一辆汽车都可以当作是`对象`。当实物被抽象成`对象`，实物之间的关系就变成了”对象“之间的关系，从而就可以模拟现实情况，针对“对象”进行编程。

> 汽车 ：
>
> ​     本质特征：  品牌    颜色     价格     厂家
>
> ​     行为 ：     行驶    启动



## 2、Js中的类

类就是类别(模板)， 类是具有相同本质特征的一类事物的总称

+ 人、动物等



js中的类就是==构造函数==



类和对象的关系：

类是对象的抽象，对象是类的实例（类是对象的抽象化，对象是类的具象化）



## 3、面向对象

==面向对象==编程的第一步就是要生成对象。而Js中面向对象编程是基于==构造函数（constructor）==和==原型链（prototyoe）==的。



### 3-1、构造函数

js语言中使用构造函数（constructor）作为对象的模板。所谓构造函数，就是提供一个生成对象的模板，并描述对象的基本结构的函数。一个构造函数，可以生成多个对象，每个对象都有相同的结构。



#### 3-1-1、构造函数的基本结构

```javascript
function fn(){
  this.name = 'name';
}

fn = function(){
  this.name = 'name';
}

// 因为要在函数体内部使用 this ，所以需要用 new 调用构造函数来生成一个对象
```



#### 3-1-2、class

==constructor 是一种用于创建和初始化 class 创建的对象的特殊方法。==

```javascript
class Fn{  // class 创建的对象
  constructor(){ 
    // 初始化 class 创建的对象 等价于3-1的两个函数
  }
}
```

- 在一个类中只能有一个名为 “constructor” 的特殊方法。

```javascript
class Fn{
  constructor(){};
  constructor(){};
  //SyntaxError: A class may only have one constructor
}
```

- 在一个构造方法中可以使用`super`关键字来调用一个父类的构造方法

```javascript
class Parent {
    constructor() {
        this.name = "名字";
    }
}

class Child extends Parent { //Child 通过 extends 继承父类 Parent 的属性和方法
    constructor() {
      	console.log(this.name); //ReferenceError:
        super(); // 访问和调用父类 Parent 函数, 也就是可以使用this
      	console.log(newChild.name); //名字
    }
}

let newChild = new Child(); // new的时候会执行一次 Child 方法
console.log(newChild.name); //名字
```



### 3-2、原型 prototype

#### 3-2-1、一个简单的原型方法的使用

```javascript
function fn(){
}

Object.assign(fn.prototype = {
    name : '我是一个name',
    out : function(){
        console.log('我是一个方法')
    }
})


var Fn = new fn();
console.log(Fn.name);   // 我是一个name
Fn.out();  // 我是一个方法
```

#### 3-2-2、原型属性

```javascript
function A(){
}

console.log(A.prototype);  // A {} : 意思是函数 A 被构造出来成为一个空对象

// A的原型属性，意思就是A可以将什么继承给别人
```



#### 3-2-3、原型

```javascript
Array.__proto__ ==> // Array的原型， 意思就是从上一级继承了什么

console.log(Array.__proto__);  // [Functon]  说明Array被赋予了函数功能

console.log(Array.__proto__.__proto__); //{}  说明函数的本质是一个对象

console.log(Array.__proto__.__proto__.__proto__ ); // null
```



