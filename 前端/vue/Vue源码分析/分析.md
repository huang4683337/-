## 说明

vue初始化部分：数据代理  模板解析  

vue更新部分：数据绑定

[vue的一个简单实现](github.com/DMQ/mvvm)

## 准备

```js
Array.prototype.split.call(li); // 将伪数组转为真实数组
node.nodeType	// 获得节点类型 元素节点1、属性节点2、文本节点3
Object.definedProperty(obj,properName,{});	// 给对象添加属性（指定描述）
Object.keys(obj); // 得到对象自身可枚举属性组成的数组
obj.hasOwnProperty(prop);  // 判断 prop 是否是 obj 自身的属性
DocumentFragment  // 文档碎片 （高效批量更新多个节点）,不会跟页面进行关联，改变文档碎片中元素不会改变页面
```

### DocumentFragment

```js
// 不会跟页面进行关联，改变文档碎片中元素不会改变页面，可以批量更新
// document 中概比那一次元素就会进行一次页面渲染（回流）

<ul id='ul'>
	<li>1<li/>  
  <li>2<li/> 
  <li>3<li/> 
</ul>

const ul = document.getElementById('ul');

// 1- 创建文档碎片
const fragment = document.createDocumentFragment();

// 2- 取出 ul 中的 li
while (ul.firstChild) {     // 如果ul下的第一个子节点存在
    fragment.appendChild(ul.firstChild);    
    // 因为没给节点都只能存在一个父节点，那么将节点插入fragment中后，ul中对应的第一个子节点就会消失
}

// 3- 更新 fragment 节点中的 li
let arr = Array.prototype.slice.call(fragment.childNodes);  // 伪数转数组
arr.forEach(node => {
    if(node.nodeType === 1){ // 如果节点为元素节点
        node.textContent = '哈哈';
    }
});

// 4- 将更新后的节点插入 ul
ul.appendChild(fragment);
```

## 数据代理

> 1、数据代理就是 通过一个对象代理另一个对象中的属性操作（读/写）
>
> 2、vue中的数据代理 是通过 vm 代替 data 中所有属性的操作
>
> 3、当你 读 / 写时，会自动触发执行 get / set 函数
>
> 4、实现了 vm.data.xx  => vm.xx

vue数据代理实现流程：

+ 通过 `Object.definedProperty()` 给 vm 添加 与 data对象的属性对应的属性描述符
+ 所有添加的属性都包含 getter / setter
+ getter / setter 去操作 data中对应的属性数据

```js
function Vue(obj){
    this.obj = obj;
}
var vm = new Vue({name:'名字'});

console.log(vm.obj.name); // 正常我们使用实例中的数据时 应该 vm.obj.name
```

```js
// 实现数据代理
function Vue(obj){
    var data = this.obj = obj;
    Object.keys(data).forEach(key=>{
        // 给Vue实例vm添加与obj属性名一一对应属性名的描述，实现vm.obj.name => vm.name
        Object.defineProperty(this,key,{
            get: function gett(){
                return data[key];  // return 后结果相当于 => get: data[key]
            },
            set: function sett(val){
                return data[key] = val;
            }
        })
    })
}

var objData = {name:'名字',age:'18'};
var vm = new Vue(objData);

console.log(vm.name,vm.age);	// 获取数据 => 名字 18
vm.name = '1';  // 修改数据
console.log(objData); // {name:'1',age:'18'}
```

## 模板解析

1、将 el 下所有的子节点取出放入创建的文档碎片（DocumentFragment）中

2、对 fragment 中所有层次的子节点递归进行编译处理

+ 对 {{}} 文本表达式进行解析
+ 对元素节点的指令属性进行解析
  * 对事件指令解析
  * 一般指令解析



### {{}} 表达式解析

1、得到满足正则匹配的 文本节点

2、从 data 中取出表达式所对应的属性值

3、将属性值设置为文本节点的 textContent



### 事件指令解析

1、从指令中取出事件名

2、根据表达式的值从 methods 中得到对应的事件处理函数对象

3、给当前元素节点半丁指令事件名和对调函数的 dom 事件监听，并将回调函数 this 指向 vm

4、指令解析完成后，移除此指令属性



### 一般指令解析

1、得到指令名和指令值  text / html / class

2、从 data 中根据表达式得到对应的值

3、根据指令名确定需要操作的元素节点是什么属性

+ v-text => textContent 属性
+ v-html => innerHTML 属性
+ v-class => className 属性

4、将得到的表达式的值设置到对应的属性上

5、移除元素的指令属性



## 数据绑定

一旦更改 data 中的某个属性值，页面上相关的值就会自动发生改变

### 数据劫持

1、数据劫持是 vue 中用来实现数据绑定的一种技术

2、基本思想：通过 Object.definePrototy() 来监听 data 中所有属性的变化，一旦数据变化就去更新界面。



### 四个重要的对象

Observer 观察

```js
对 data 中的每个属性 添加 get / set
```



dep 订阅者

```js
什么时候创建？
初始化时，对 data 进行数据劫持前一步创建的。

结构：
id：每个属性
subs： 存放每个属性对应的 watcher
```



watcher

```
什么时候创建？
初始化(解析) 花括号{{}} 和 一般指令时 创建了watcher

个数：与表达式的数量一一对应（事件指令除外）

结构：
用于更新页面的回调函数
vm
对应的表达式
存放每个属性对应的 dep => {dipId:dep}
当前表达式对应的值
```



数据改变时

```js
vm.name=1 => data 中的 name 值发生改变 => name 中的 set() 调用 => 属性对应的dep => dep 中所有的 watcher 触发 => 调用跟新方法渲染页面
```



dep 和 watcher 之间关系

```js
多对多的关系
	一个 data 中的属性对应一个 dep => 在一个属性被多个表达式使用时;
	一个表达式对应一个 watcher => 包含多个 dep => {{a.b.c}} 一个表达式用了a、b、c三个属性;
```

dep 和 watcher 之间关系怎么建立的

```js
在 data 属性中的 get() 中建立的
```

dep 和 watcher 之间关系什么时候建立的

```js
初始化时解析模板中的表达式会创建一个 watcher 对象时
```

