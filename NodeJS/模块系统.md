

# 模块系统

## 1、什么是模块化

+ 文件作用域

+ 通信规则

  - 加载方法

  - 导出方法

    ​

## 2、CommonJs 模块规范

### 2.1 加载 `require`

```javascript
var 变量名 = require('模块标识符');
```

#### 2.1.1  require 加载规则

###### 从上到下依次加载并执行

```javascript
console.log('第一行');
require(./b.js);
console.log('第三行');

// 执行后，输出的结果从上到下的顺序
'第一行'

加载b.js, 执行完毕b.js代码

'第三行'
```

###### 优先从缓存加载

```javascript
a.js
var b = require('./b.js');
var c = require('./c.js');
console.log(c);

b.js
console.log('b.js 被加载了');
require('./c.js');

c.js
console.log('c.js 被加载了');
module.exports = {
    'name':'我是c.js'
}

//猜测执行结果：
/*
加载b.js

执行b.js ==> b.js 被加载了
加载c.js

执行c.js ==> c.js 被加载了

加载c.js ==> 因为在b.js中已经加载过了，这次就会从缓存中加载
执行c.js

输出c模块 ==> { name: '我是c.js' }
*/

//实际执行结果为：
/* 
b.js 被加载了
c.js 被加载了
{ name: '我是c.js' }
*/
```

###### 判断模块标识

+ 非路径的模块标识符：require('模块名/包名');

  ```javascript
  核心模块：本质上是文件，不过被编译成二进制放在应用程序中。 我们只需要按照名字加载
  	
  三方包模块：
  	加载规则：node_modules/三方包的名字/package.json文件中的 main 属性所对应的文件
      
      		如果当前包中 package.json 或者 main 属性不存在，会默认使用 index.js文件

  			如果当前包中 package.json、 main 属性、 index.js不存在，会默认向上级查找，直到根				目录为止
  ```

+ 路径的模块标识符：require('路径');



###  2.2 导出 `exports 或者 module.exports`

###### 导出单个

```javascript
module.exports = function (){}
```

###### 导出多个

```javascript
module.exports = {
  add: function (){},
  sub: function (){}
}

或者

export.add = function (){}
export.sub = function (){}
```



### 3、exports 和 module.exports 区别

 ```javascript
exports = module.exports;
 ```

```javascript
node中有一个 module对象， module 对象中有一个 exports 对象， 在最后面有个 return module.exports
var module = {
    exports:{

    }
}
return module.exports 
```



